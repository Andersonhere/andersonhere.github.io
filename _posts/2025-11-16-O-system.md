## 操作系统（Operating System）学习记录

本文会梳理关于操作系统的三大部分：虚拟化，并发，持久化。其中关于虚拟化会分为cpu虚拟化和内存虚拟化。

目的在于了解操作系统中做了哪些事情，让其满足用户的需求，变得及其易于使用，本文会用以下方式来标注重要问题，通过这些重要问题来引出遇到的一些具体问题。

> [IMPORTANT]
>
>  操作系统通过哪些机制和策略来实现虚拟化？
>  操作系统如何有效地实现虚拟化？
>  需要哪些硬件支持？

**虚拟化通俗来讲就是操作系统通过将物理资源转为通用并且易用的虚拟形式的一项技术**，如：cpu的并发模型，虚拟内存的设计，等。

下面会通过几个代码示例来具象化的展示出操作系统虚拟化的成果

####  1、虚拟化cpu
```c++
#include "common.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: cpu <string>\n");
        exit(1);
    }
    char *str = argv[1];
    while (1) {
        Spin(1);
        printf("%s\n", str);
    }
    return 0;
}
```


```bash
编译：gcc -o cpu cpu.c -Wall
运行：./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
同时运行4个
```

我们在刚开始学习编程时大多数都操作过这种场景：同时运行多个相同的进程，并且他们似乎在同时运行。

这种现象就是cpu虚拟化的一种表现，操作系统在cpu的支持下提供了这种假象，即拥有非常多的虚拟cpu的假象。

**将单个cpu转换为看似无限数量的cpu从而让许多程序看似同时运行，这就是所谓的虚拟化cpu**。



#### 2、虚拟化内存

```c++
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int
main(int argc, char *argv[])
{
int *p = malloc(sizeof(int)); // a1
 assert(p != NULL);
 printf("(%d) memory address of p: %08x\n",
 getpid(), (unsigned) p); // a2
 *p = 0; // a3
 while (1) {
 Spin(1);
 17 *p = *p + 1;
intf("(%d) p: %d\n", getpid(), *p); // a4
 }
 return 0;
 }
```

```bash
prompt> ./mem
(2134) memory address of p: 00200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
```





会涉及到常见的操作系统相关知识，如：

在cpu虚拟化部分会以进程为载体进行梳理，通过对进程的支持来描述出cpu的发展

- 进程的数据结构，创建，状态
- 进程的相关api使用和设计思想(fork()  , wait(),   exec())
- 受限的直接执行机制
- 进程调度算法介绍，以及可行性分析
- 多级反馈队列的诞生
- 多处理器的调度
- 内存屏障的原理及实现

在内存虚拟化部分会描述出内存模型的发展路线

- 明确虚拟化内存的目标

- cpu的时分共享对内存模型的要求

- 汇编直接操作内存地址
- 静态地址转换，动态地址转换，硬件MMU的支持
- 分段地址设计，空闲空间管理，内部碎片和外部碎片
- 分页的必要性，页表设计和页目录设计的必要性，多级页表的级数如何确定。
- 大页对性能的影响，适用于什么场景
- 另外关于硬件的发展，TLB是如何出现的。有什么作用
- 关于cpu访问内存的过程，不同情况下的缺页终端导致什么现象
- 内存压力较大时会发生什么
- 内存的交换策略是什么

并发部分主要分析一下几个部分：

- 原子操作，临界区，竞态条件
- 锁的基本思想，实现锁的前提，硬件如何支持
- 锁的实现以及如何进行优化的，优化的目标是什么
- 不同的数据结构如何保证高性能的线程安全
- 条件变量的使用以及常见问题
- 信号量作为锁来使用，作为条件变量来使用，如何实现信号量
- 常见并发问题，死锁和非死锁问题
- 基于事件的并发，网络io模型

持久化部分TODO::

### 一、cpu虚拟化
进程是虚拟化的cpu
地址空间是虚拟化的内存
creat